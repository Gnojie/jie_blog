## 插件化概念

🤔 插件化/组件化(楼层异步组件)/函数式编程(组合)？

- 前端打包工具的插件化 🔌
  - webpack的各种css、vue的 plugin
  - babel的各种需尝鲜版新ES语法编译插件
  - rollup
  - vite
- 前端框架的插件化
  - Vuejs渐进式的router、vuex等
  - React
  - UmiJS、Eggjs、DvaJS等
- 代码编辑器
  - VSCode的各种插件: prettier、主题皮肤等
- 浏览器
  - 谷歌浏览器的插件市场
  - url获取到的网页可以视为插件，浏览器窗口则是主体程序

优点：
- 减少主体的复杂度，精简核心
  - webpack 、babel 大部分代码都是插件，主体主要是软件生命周期调配，状态流转等，以及少量核心能力的实现
- 渐进式，按需使用
  - Vuejs，插件更多是对其能力上的一个补充
- 独立于主体，新增功能不需要发布升级
- 可扩展性，借助社区提升生命力


设计思路：
- 哪些是易变的，哪些是相对稳定的
  - 易变的部分应暴露出相应的能力由插件来完成
- 插件如何影响主体程序
  - 通常会以扩展行为，修改状态，变更展示的方式体现

## 设计一个 🔌插件化计算器

### 普通计算器

```js
// 计算器
class Calculator {
  construct(initVal) {
    this.num = initVal;
  }
  // 加法
  add(num) {
    this.num = this.num + num;
    return this;
  }
  // 减法
  subtract(num) {
    this.num = this.num - num;
    return this;
  }
  // 结果
  result() {
    return this.num;
  }
}

const myCalculator = new Calculator(5);
myCalculator.add(5).subtract(2).result(); // 8
```
👆 只有加减法

### 插件计算器-插件定义

按照设计思路：
- 主体是运算：当前值和一个新值的运算过程，这部分是稳定的
- 支持的运算逻辑(加/减法🔧工具函数)是可扩展的，适合做成插件

👇 运算插件提供计算逻辑作为回调函数
```ts
// 插件类型声明
interface Plugin {
  name: string;
  calculate(num: number) => this;
}

// 加法插件
class AddPlugin implements Plugin {
  name: 'add',
  calculate(num) {
    this.num = this.num + num;
    return this;
  }
}

// 减法插件
class SubtractPlugin implements Plugin {
  name: 'subtract',
  calculate(num) {
    this.num = this.num - num;
    return this;
  }
}
```
👆 name 用于调用方指定使用哪个插件计算逻辑，主体程序调用相应插件提供的回调

### 插件计算器-主体程序

- 主体程序调用相应的回调函数存储结果，用于下一次计算

```js
// 程序主体，定义程序核心逻辑是增加计算器运算能力
class Calculator {
  plugins = [];
  construct(initVal) {
    this.num = initVal;
  }

  // 安装插件
  use(plugin) {
    this.plugins.push(plugin);
    this[plugin.name] = plugin.calculate.bind(this);
  }

  // 结果
  result() {
    return this.num;
  }

  // 输出插件信息，根据插件信息了解支持什么运算
  help() {
    return `support ${this.plugins.map(plugin => plugin.name).join(',')}`;
  }
}
```

### 插件计算器-使用

```js
// 初始化计算器
const myCalculator = new Calculator(5);
// 安装插件
myCalculator.use(new AddPlugin());
myCalculator.use(new SubtractPlugin());
 
myCalculator.add(5).subtract(2).result(); // 8
```

## 插件化系统组成

![](https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221214111326.png)

- Program: 主体程序，有着一定顺序的生命周期 Hooks，可以在不同时期调用插件
- Plugin Loader: 插件管理逻辑，对应👆插件化计算器的 use，最基础的是安装、调用逻辑，可以有复杂的管理逻辑，如卸载插件等
- Plugins: 插件列表
- Plugin Impl: 插件实现(Plugin Implementation)，就是插件内容
- Plugin Interface: 插件接口声明，对应👆插件化计算器的类型声明，用于给开发者了解一个插件的基本属性
  - 也可以看作是主体程序，注入给插件的数据状态，或特殊回调

## webpack

webpack 核心模块(主体程序)为compiler 和 compilation，他们都有各自的生命周期钩子（Hook）

webpack 核心(主体程序)定义生命周期（或者叫事件流）
插件管理逻辑(Plugin Loader)，就是在各个生命周期中调用插件在对应生命周期注册的方法

👆 相对于插件化计算器，一个插件除了定一个插件名、回调函数外
还需要把回调函数指定为不痛的webpack Hooks调用

因为这样主体程序中就涉及生命周期中插入逻辑
那么这段逻辑是
- 同步执行/异步执行
- 并行执行/串行执行
- 执行结果需不需要影响之后的生命周期

因此主体程序为了适应插件，需要有完善的生命周期事件处理机制
`webpack` 封装了一个 `Hook` 的核心库 `Tapable` ， `compiler` 和 `compilation` 都是基于 `Tapable` 的实现

👇 也就是webpack的生命周期Hooks有一定的复杂逻辑在
![](https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221214112944.png)

TODO: 关于 `Tapable` 我们在 [重学webpack](../webpack/重学webpack-04plugin.md) 里详细讲解

这里有一个模糊的概念即可：webpack 的Hooks事件处理机制就是一个 EventEmitter(发布订阅模式等) 

## TODO: rollup

rollup怎么处理插件 [PluginDriver](https://github.com/rollup/rollup/blob/master/src/utils/PluginDriver.ts)


## jQuery

```js
(function ($) {
  $.fn.myPlugin = function () { ... }
})(jQuery)
```

![](https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221214123631.png)

👇 示例

![](https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221214123927.png)

![](https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221214123939.png)

- pluginCore：主体程序通过原型链来挂载不同的插件
  - 手动获得jQuery实例(主体对象)后调用插件，而不是主体程序有生命周期Hook自动调用插件
  - 😖 更像是新增了🔧工具方法，而放置的地方不是全局变量，也不想自己引入，于是放到这个主体上
- plugin：无限制，可以是JavaScript的类型，一般是实现具体功能的模块，比如，日期选择器等。

### babel

👇 babel插件结构
```js
function () {
  return {
    name: '插件名',
    visitor: {
      enter(nodePath) {},
      exit(nodePath) {},
      [NodeType](nodePath) {},
      // NodeType指的是babel转译AST得到的节点类型，利用这个节点类型作为回调函数的key
    }
  }
}
```
可以看出和 👆插件化计算器非常像，只是回调函数改为了一个对象存储限制变量名的函数属性

👇 箭头函数转译插件 [babel-plugin-transform-arrow-functions](https://github.com/babel/babel/blob/main/packages/babel-plugin-transform-arrow-functions/src/index.ts)

```ts
import { declare } from "@babel/helper-plugin-utils";

export interface Options {
  spec?: boolean;
}

export default declare((api, options: Options) => {
  api.assertVersion(7);

  const noNewArrows = api.assumption("noNewArrows") ?? !options.spec;

  return {
    name: "transform-arrow-functions",

    visitor: {
      ArrowFunctionExpression(path) {
        // In some conversion cases, it may have already been converted to a function while this callback
        // was queued up.
        if (!path.isArrowFunctionExpression()) return;

        path.arrowFunctionToExpression({
          // While other utils may be fine inserting other arrows to make more transforms possible,
          // the arrow transform itself absolutely cannot insert new arrow functions.
          allowInsertArrow: false,
          noNewArrows,

          // TODO(Babel 8): This is only needed for backward compat with @babel/traverse <7.13.0
          specCompliant: !noNewArrows,
        });
      },
    },
  };
});
```

- 第一步，执行该插件，获取到包含visitor对象；
- 第二步，`AST` 遍历节点，检测nodePath的type === 'ArrowFunctionExpression'，寻找到vistor对象的中key为 ArrowFunctionExpression的函数；
- 第三步，将nodePath传入该函数进行调用（AST在这步被修改）；

---

🤔思考: babel主体程序，怎么管理多个插件对同一个AST节点类型做转译回调？

合并所有使用到的babel插件的属性：
- 通过解析babel的配置文件（或者命令行--plugins参数），获取Babel配置的所有插件的描述；
- 将插件的require进内存，获得插件函数，并执行插件函数，获取到多个包含vistor字段对象；（详细逻辑：[@babel/core/src/config/full.js](https://github.com/babel/babel/blob/fa975bf7cd2b9054faaff107a79e41dcaad305b1/packages/babel-core/src/config/full.js)）
- 将多个包含vistor字段对象整合成一个大的visitor源码展示（详细逻辑：[@babel/core/src/transformation/index.js](https://github.com/babel/babel/blob/fa975bf7cd2b9054faaff107a79e41dcaad305b1/packages/babel-core/src/transformation/index.js#L107)）：
- AST遍历时，每个节点根据 NodeType，来获取 visitor[NodeType]，并依次执行

```js
// @babel/traverse
const visitor = traverse.visitors.merge(
  visitors,
  passes,
  file.opts.wrapPluginVisitorMethod
)
```
![](https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221214131255.png)

👆 节点类型对应的转译插件逻辑变成了 Array<function(nodePath)>

---

## vue-cli

> 内部源码是插件化的



## React插件化组件库-DevExtreme Reactive

目前包含了 Grid / Chart / Scheduler 三个复杂组件，这三个组件都是基于一个插件化框架进行开发的。

```jsx
import { PluginHost, Plugin, Template, Getter, Action } from '@devexpress/dx-react-core';

export default function PluginRoot(props) {
 const { chidren } = props;
 return <PluginHost>{children}</PluginHost>;
}

export function FeatureA() {
 return (
   <Plugin name="A">
     <Template name="...">...</Template>
     <Getter name="..." />
     <Action name="..." />
   </Plugin>
 );
}
export function FeatureB() {
 return (
   <Plugin name="B">
     <Template>...</Template>
     <Getter name="..." />
     <Action name="..." />
   </Plugin>
 );
}
```

👆 类似Vuejs插槽， `plugin标签` 内的 `name标签` 会插入到主体程序的 `pluginhost标签` 内的 `name` 的位置
```jsx
// App.jsx
import PluginRoot, { FeatrueA, FeatureB, ... FeatureN } from './MyComponnent;'

const App = () => (
 <PluginRoot>
   <FeatureA />
   <FeatureB />
   ...
   <FeatrueN />
 </PluginRoot>
);

ReactDOM.render(<App />, rootNode);
```

## 参考资料

- [前端领域的插件式设计](https://mp.weixin.qq.com/s/_Qy8wScgq86vLBwNU-tTfw)

UmiJS？

- [TODO:异步组件设计](./异步组件设计.md)