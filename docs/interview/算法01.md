> 算法一般出现在笔试环节
> 大厂在面试环节也会让你写伪代码或者口头讲述实现逻辑

> 准备一些经典的数据结构算法是很有必要的
> 当然尽量能在工作的时候思考一下每一种类型的数据结构操作方法



- 栈、队列、链表
  - 有序，相连的
- 集合、字典
  - 无序的池子
- 树、堆、图
  - 特殊条件相连的

## 栈stack-后进先出

```js
// [].pop() 删除最后一项并返回
const stack = [];
stack.push(1); // 进栈
stack.push(2);
const item1 = stack.pop(); // 出栈
const item2 = stack.pop();
```

---

### 10进制转二进制
数字除2取余数的每个余数倒序输出
也就是除2之后入栈，再出栈输出结果

---
### 函数调用栈
指的是嵌套调用函数，开始执行和执行结束的顺序
后执行的函数，先执行结束

> 不是事件队列，调用栈是同步函数执行，事件队列是异步函数存储池子，是先进先出的

---
### 有效括号校验

多种括号闭合，并且`{(})`要正确闭合

收集所有不同字符串括号到数组，数组长度相同则闭合。

有效-括号位置要对应上，左括号在第1，右括号要在最后

入栈时存数组index，对应的右括号要是，(length-1)-index

遍历左括号，跟右括号数组匹配index

- 遍历一次收集括号
- 遍历左括号匹配右括号index，多次

↑ 不使用栈的思想，是普通的集合

遍历收集不同的左括号，遇到右括号，出栈对应的左括号，出栈只能出最上面的，即不对应就不出，不需要知道对应的左括号在哪

```js
const a = '{{(})}';
const arr = a.split('');
const left = ['{','('];
const right = ['}',')'];
const map = new Map([
  ['{','}'],
  ['(',')'],
]);
const stack = [];
// 奇数字符串不可能闭合 除2有没有余数 不为0就是奇数
if(arr.length%2) {
  console.log('非有效括号')
  return
}
for(let i = 0; i<arr.length;i==){}
  const item = arr[i]
  if(left.includes(item)){
    stack.push(item)
  }else if(map.get(item === stack[stack.length-1])){
    stack.pop()
  }else {
    break;
  }
}
if(stack.length) {
  console.log('非有效括号')
  return
}
console.log('是有效括号')
```
什么时候考虑栈
- 遍历一次解决问题
- 不一定要每一项都遍历处理时
- 栈可以给的状态：栈的空状态，栈顶元素（栈的最后一项）
---
## 队列queue-先进先出

```js
// [].shift() 删除第一项并返回
const queue = [];
stack.push(1); // 入队
stack.push(2);
const item1 = stack.pop(); // 出队
const item2 = stack.pop();
```
---
### 异步函数的事件队列

---
### 计算最近请求次数


---
### axios链式调用时，调用一个删除一个shift



忘了具体

---
## 双端队列



既可以先入先出也可以先入后出


---
## 链表linkedList

```js
const a = { val:'a' };
const b = { val:'b' };
const c = { val:'c' };
a.next = b;
b.next = c;
let pointer = a; // 指针-从a开始
while(pointer.next) {
  console.log('处理当前项', pointer.val)
pointer = pointer.next; // 移动指针
}
// 查(取)
// 增 ab之间插入d

const d = { val:'d' };
a.next = d; // 改变一项就会使原链表断掉
d.next = b; // 把断掉的链表接回来
// 删 a后面的d
a.next = b
// 这里的增删都是在已知所有项的时候来手动操作的，当链表项由参数传入，链表处理只知道下一项，不知道上一项和下下一项，怎么操作
```
双向链表也就是多一个向前的指针而已如pre


什么时候考虑链表

- 遍历所有项
- 不在意项的位置，有自己的顺序实现
- 操作(增删)项时不希望被数组的顺序束缚（为什么不用数组）
### 链表和数组



数组

- 优点
  - 高效的随机访问能力，有下标就能读取到
- 缺点
  - 增删触发其他项移动，这里移动有遍历操作的损耗的
  - （删除项如果不需要移动顺序的话，可以把最后一项放到删除项那里，这样其他项其实是不需要变动的。这样删除项损耗最小，但是顺序就乱掉了）


数组适合读

链表适合写

---
### 删除链表指定节点



1->2->3->4，要求删除指定的节点(参数)
按照next来遍历while



找到要删除的节点，让上一节点next指向下一节点



问题：没办法拿到上一项

```js

function remove(val) {

  // 链表的遍历是next

  let pointer = a; // 指针-从a开始

  while(pointer.next) {

    if(pointer.val === val) {

      // 找到了要删除的节点

      // 让上一项指向下一项（没办法拿到上一项

      per.next = pointer.next;

    }

    console.log('处理当前项', pointer.val)

    pointer = pointer.next; // 移动指针

  }
}
```
换种思路，把要删除项的值变成下一项，指针为下下一项



1->2->3->4



1->3->3->4



1->3------>4



           3->4

```js

function remove(val) {

  // 链表的遍历是next

  let pointer = a; // 指针-从a开始

  while(pointer.next) {

    if(pointer.val === val) {

      // 找到了要删除的节点

      // 当前项变成下一项 指针指向下下项

      pointer.val = pointer.next.val

      pointer.next = pointer.next.next

    }

    pointer = pointer.next; // 移动指针

  }
}
```
---
### 删除有序数字链表中的重复元素



有序数字所以都是按顺序的，重复会相邻如 123有序，重复只能相邻



判断当前项和下一项的值相同就删除(下一项指向下下项)下一项

---
### 链表反转



反转2个节点



当前项的值变成下一项，next指向上一下项（不知道上一项



双指针遍历链表



一个指针从第一项开始



一个指针从第二项开始



1     2 3 4

↓     ↓ ↓  ↓

null 1 2 3  4



第二个指针的值只用来暂存



给第一个指针来指



4 3 2 1

```js

let pointer1 = a; // 指针-从a开始

let pointer2 = null; // 先不开始 落后一个



while(pointer1.next) {

  console.log('指针1的值', pointer1.val)

  console.log('指针2的值', pointer2 && pointer2.val)

  const temp = pointer1.next; // 给移动指针做标识下一项

  pointer1.next = pointer2; // 第一个指针指向第二个(前一项)

  pointer2 = pointer1; // 移动指针2

  pointer1 = temp; // 移动指针1

}
```
用落后的指针来获得前一项

---
### 多位数转为链表求和



123 + 789



3+9 2+8 1+7



再倒序拼接

---
### 判断是否有环形链表



用多个落后的指针来遍历，当落后的项跟当前项相同证明后面的链到前面的



多指针的作用来获取前面的项

---
### 原型链


---
## 字典

> 字典的重点是创建出有效的字典。（字典查找根据key直接得值）

### 无重复字符的最长子串


用指针，这里的指针不是链表的指针



链表指针内嵌下一项，这里只是数组下标取下一项而已，是下标index，并且指针完全由自己控制，想怎么走怎么走



指针作用：扫描字符存入字典



用两个指针，左指针做标记，右指针循环存入字典



两个指针都在开头，第二个指针往右移动，移动发现值跟前面的相同，则第一个指针往右移动，这里不是左指针+1，而是左指针移动到重复项那里（节省不必要的循环

```js

// 找出字符串中无重复字符的字符串的长度

// 如下会有很多无重复字符串，但是要找出长度最长的，所以用到了Math.max

(()=>{

  const str = 'qasdxas' // aabcdea->abcde

  

  let pointer1 = 0 // 左指针

  let length = 0 // 没有重复字符的长度(左指针到右边的数量

  const dict = new Map()
  for(let i=0;i

    const item = str[i];

    // i是右指针 区间是左到右

    if(dict.has(item)&& dict.get(item)>=pointer1) {

      // 字典中有值且不在左指针区域内,证明重复 移动左指针到左边重复项的后一位 

      pointer1 = dict.get(item)+1

      // dict.clear()

      // 清空不可行，存入字典依赖右指针，清空会导致右指针过了的项无法判断重复

      // 如上a重复，清空右指针之前的字典，右指针到s时会不知道s已经重复

      // 如果要清空，应该清空左指针前的字典（不好操作

      // 因此判断重复同时判断重复的项在左指针前(包含左指针)都当重复，是最方便的

    }

    dict.set(item, i);

    length = Math.max(length, i - pointer1 + 1)

  }

  console.log(length)
})()
```
### TODO: 最小覆盖子串



用栈队列作为字典不也行？



操作出栈入栈

> 指针在算法里面无敌了吧。。。字典都要靠指针来创建

## 树



分层、一对多的数据结构、DOM树、级联选择器、树形数据

### 深度优先遍历-递归

```js

(()=>{

  const tree ={

    val:'a',

    children:[{

      val:'b',

      children:[{val:'d',children:[]}, {val:'e',children:[]}]

    },{

      val:'c',

      children:[{val:'f',children:[]}, {val:'g',children:[]}]

    }]

  }

  

  // 递归深度遍历

  function test(tree) {

    console.log(tree.val)

    tree.children.forEach(item => {

      test(item)

    });

  }

  test(tree) // a-b-d-e-c-f-g

})()
```
依靠树组foreach遍历的顺序，进入哪层打印哪层，同级的会在数组后面，因此从上到下，从左到右

### 广度优先遍历- 队列（节点出队的同时入队子节点）-队列



for循环进数据，出队的时候输出当前节点并入队子级



用一个队列循环while，类似事件队列的循环,数组有值就自动循环，自动入队，不停执行

```js

(()=>{

  const tree ={

    val:'a',

    children:[{

      val:'b',

      children:[{val:'d',children:[]}, {val:'e',children:[]}]

    },{

      val:'c',

      children:[{val:'f',children:[]}, {val:'g',children:[]}]

    }]

  }

  // 队列深度遍历

  function test(tree) {

    const queue = [tree]

    while(queue.length) {

      // 队列循环(类似事件队列的循环,数组有值就自动循环自动入队)

      const item = queue.shift();

      console.log(item.val) // 输出当前节点

      item.children.forEach(element => {

        queue.push(element)

      });

    }

  }

  test(tree) // a-b-c-d-e-f-g

})()
```
## 二叉树



每个节点只有两个或更少节点



数据结构子级不是数组，是具体的属性如 ` { val:", left:{}, right:{} } `
### 先序遍历(深度优先递归)
根节点-左子树-右子树

```js

(()=>{

  const tree ={

    val:'1',

    left:{

      val:'2',

      left:{val:'4',left:{},right:{}},

      right:{val:'5',left:{},right:{val:'6',left:{},right:{}}}

    },

    right:{

      val:'3',

      left:{val:'7',left:{},right:{}},

      right:{val:'8',left:{},right:{}}

    }

  }

  // 队列深度遍历

  function test(tree) {

    if(tree&&tree.val) {

      console.log(tree.val); // 根节点

      test(tree.left); // 深度进入左边才会开始右边

      test(tree.right);

    }

  }

  test(tree)
})()
```
跟普通的深度遍历类似，不过因为树的结构，普通的子级是数组所以是foreach进入，二叉树的子级是属性项直接进入


### 中序遍历(深度优先递归)
左子树-根节点-右子树



从下到上，从左到右

```js

test(tree.left);

console.log(tree.val);

test(tree.right);
```
只是执行顺序变了

### 后序遍历(深度优先递归)
左子树-右节点-根节点



从下到上，从右到左

```js

test(tree.left);

test(tree.right);

console.log(tree.val);
```
只是执行顺序变了


### 不使用递归实现先中后序遍历



用栈模拟递归

## 图

## 堆

## 排序算法

### 原型链
原型链的数据结构就是链表
_proto_ 就是 next

实现一个instanceOf
```js
instanceOf(A,B) {
  const pointer = A;
  while(pointer) {
    if(p===B.prototype) {
      return true
    }
    pointer = pointer._proro_
  }
  return false
}
instanceOf([], Array)
```
判断第一个参数原型链上是否含有第二个参数
第一个参数是完整的链表，第二个参数是一项
且第一个参数就链表头，遍历指针的值是否等于第二个参数的原型，等于则有

### json
```js
const json = {
  a:{b:{c:'json.a.b.c'}},
  d:{e:'json.d.e'}
}
const path = ['a','b','c'];

// 根据path的数组层级取到json对象深层数据
path.forEach(item=>{
  // json对象是链表，指针从外往里指，path的每一项就是指针，forEach就移动指针
  const pointer = json;
  pointer = pointer[item];
})
```
不太像链表吧，next都不明显，虽然从外往里遍历来指向是链表的特征，next就是子项
这么说所有的 xx.xx.xx 都是链表了

## 总结
栈、队列、链表
讲究先后进出，讲究指针next
证明这些都是有序的数据结构
另外这些都是可以有重复项的

那么还有无序且不能有重复项的数据结构，集合

## 集合
无序、唯一的
ES6的 Set

集合的常用操作
去重、判断是否在集合里、求两个集合的交集
```js
// 去重
const arr = [1,1,2,2]
const newArr = [...new Set(arr)];
// 判断是否在集合里
[new Set(arr)].has(1)
// 两个集合的交集 遍历其中一个集合每一项判断是否在另一个集合里面
const arr1 = new Set([2,3,4,5])
const arr2 = new Set([1,2,3,4])
const arr3 = new Set([...arr1].filter(item=> arr2.has(item)))
```
⬆️ 集合就是普通的数据堆(对象、数组)，只不过过滤了一次重复项而已

## 字典
以key value形式存储的数据
ES6 的Map
Map是映射的意思，更好的解释字典这种数据结构

Object和json也是字典咯，但是Map这种数据类型性能更好？
### 2个数组的交集
跟Set的方法不同
这里用字典思想
创建字典：遍历第一个数组，以key为数组项，值为true或随便，进行存储，就做好了去重
匹配字典：再遍历第二个数组，判断是否在字典里面，再则取出来，并且删除字典项，去重
```js
function test(arr1, arr2) {
  const dict = new Map();
  let res = [];

  // 创建字典
  arr1.forEach(item=>{
    dict.set(item, true)
  })
  // 匹配字典
  arr2.forEach(item=>{
    if(dict.get(item)) {
      res.push(item);
      dict.delete(item)
    }
  })
  return res;
}
```

### 找出数组项中2个相加等于目标值的下标
遍历数组判断字典中有没有等目标值-当前项的值，有则匹配成功，没有则存入字典
字典key为数组项，value为下标
```js
const arr = [11,1,2,7]
const target = 9
const dict = new Map();
const res = [];

for(let i=0;i<arr.length;i++) {
  const item = arr[i]; // 当前项的值
  const otherItem = target - item // 期望匹配的值
  if(dict.get(otherItem)>-1) { // 判断字典有没有期望值
    res.push(i); // 有则返回当前项和字典项下标
    res.push(dict.get(otherItem));
    break;
  } else {
    dict.set(ite,i); // 字典没有则当前项存入字典
  }
}
console.log(res)
```

### 无重复字符的最长子串


有key value的都可以考虑字典的数据结构，感觉什么场景都可以用吧。。。


