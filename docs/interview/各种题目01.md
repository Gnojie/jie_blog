[[toc]]

### 1. v-show和v-if的区别
- show通过`css display` 控制显示和隐藏
- if控制真正的渲染和销毁，而不是显示隐藏
- 频繁切换用show，否则用if
- TODO: css display 的本质是什么

### 2. v-for为什么要用key
- for用的key不能是 index 和唯一随机值
- diff算法通过选择器字符串和key来判断是否 sameNode
- 用key方便diff算法，做到减少渲染次数，提升渲染性能

### 3. 描述Vue组件生命周期(父子组件)
- 单组件生命周期图
- 父子组件生命周期关系

### 4. Vue组件如何通信
- 父子组件 props、$emit()
- 自定义事件 直接用vue实例做eventbus, `event.$on 、event.$off 、event.$emit`
- vuex

### 5. 描述组件渲染和更新过程/请描述响应式原理
- 官方文档图示
- 包含模版渲染成虚拟dom、数据双向绑定的getset拦截和观察、更新虚拟dom成真实dom的diff算法

### 6. v-model的实现
- input元素的`value = this.xxx`
- 绑定input事件 `this.xxx = $even.target.value`
- data更新出发re-render

### 7. computed的特点
- 有缓存，data不变不会重新计算(可以看看是怎么实现的)
- 提高性能

### 8. 组件data为什么必须是一个函数
- 每个vue文件都会编译到同一个vue实例下，多个组件的属性如果是对象会互相干扰，函数则会是一个闭包

### 9. 何时需要用到beforeDestory
- 解除eventbus自定义事件时 `event.$off`
- 清除定时器
- 解绑自定义的DOM事件，如 window scroll 等

### 10. 什么是作用域插槽
- 父组件想拿到子组件的数据如data时用到
- TODO: 实现一个表格组件就可以知道了

### 11. vuex和 action 和 mutation 有何区别
- action 中处理异步，mutation不可以
- mutation一般做原子操作
- action可以整个多个mutation

### 12. vue-router模式
- hash模式
- history模式 (服务器支持)
- 实现原理

### 13. 将中间组件所有的props传递给子组件
- `<child :topProps="$props">`
- $attr

### 14. 何时用到keep-alive
- 缓存组件，不需要重复渲染时,如多个静态tab页的切换
- 优化性能

### 15. 用vNode描述一个dom结构
<!-- ![5f604da2d0b8a32f36d6ee7242a94f0f.png](evernotecid://A8CC14F8-F351-4473-9E82-5EFAB88A4F7D/appyinxiangcom/18783918/ENResource/p1757) -->
### 16. 监听data变化的核心API
- `Object.defineProperty`
- 深度监听原理,监听数组的实现
- 有何缺点

### 17. Vue如何监听数组变化
- `Object.defineProperty`不能监听数组变化
- 重新定义原型,重写`push、pop、splice`等方法
- `Proxy`原生支持监听数组变化

### 18. Vue为何是异步渲染,$nextTick
- 异步渲染(以及合并data修改),用于提高渲染性能
- `$nextTick` 用于在DOM更新完之后,触发回调

### 19. 简述diff算法过程
- `patch(elem,vnode)` 和 `patch(vnode,newVnode)`
- `patchVnode` 和 `addVnodes` 和 `removeVnodes`
- `updateChildren` (局部比对 key的重要性)

### 20. css的link标签和@import的区别
1. 概念
  - link标签属于HTML的标签，不仅仅可以加载样式还可以定义一些属性ref
  - @import属于CSS的语法，只能加载外部样式
2. 加载顺序
  - link标签，加载页面时同时加载样式
  - @import，页面加载完成，才开始加载外部样式(如果把主页面样式写成@import会导致页面加载出来有一段时间样式缺失)
3. DOM操作区别
  - link是个标签，可以通过js新增删除样式
  - @import是css语法，无法通过js操作

### 21. display:none、visibility:hidden、opacity:0的区别
- opacity通过透明度隐藏dom，还有占位和可以点击（依然要渲染，消耗性能）
- visibility控制可视性隐藏dom，还有占位和不可点击（不渲染，保留空间，消耗一丢丢性能）
- display盒模型彻底隐藏（不渲染，不保留空间）

性能：
浏览器GUI渲染线程、浏览器JS引擎线程
css渲染过程：布局(排列、重排、回流)->绘制(重绘)

开关`opacity`和开关`visibility`都会触发重绘


### 22. https为什么更安全，怎么验证证书
> [这一次，彻底理解 https 原理](https://juejin.cn/post/6844904038509576199)
https防的是服务器中间人

浏览器 --访问--> B站

浏览器 --访问--> 中间人 --转接--> B站

中间人可以通过基站或不安全的wifi等插入进来，此时你的访问被接管，是否转发到目标访问都取决于中间人，且上送数据都被接收

https给访问目标如B站，添加认证，每次访问都需要符合认证。

浏览器会查看访问目标服务器的证书是否和域名匹配
但是证书是公开的，也就是中间人可以下载目标服务器的证书到自己的服务器里，让浏览器检查

除了校验证书内容，还会校验颁发者，当然颁发者也是公开的，中间人也可以配置自己证书是这个办法者

这些公开不加密的证书信息可以伪造，但是真正校验证书的是加密签名(签名只能用一次)，服务器上除了要有证书还要有个公开的共钥和不公开的私钥，用于解密证书信息

RSA非对称加密，只能用一次的签名防篡改

### 23.script 标签中 defer 和 async 的区别？
> html加载js，有两个步骤:1.下载js 2.加载js
> `异步script`就控制`下载/加载时机`的

- `script` ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。
- `async script` ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。
- `defer script` ：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本

### scss样式穿透原因及原生原理
内部写样式不生效，改为全局样式后生效的原因
在vue中用了scope组件样式，去改第三方组件之类的样式不生效的原因是第三方组件的样式是全局的，内部组件scope不会给第三方组件加data码，这样组件选择器会选不中它
scss提供给组件父级下的选择器加deep，让这部分样式编译成全局样式，不带data码

如果是原生css会不会遇到样式穿透的问题，如何解决

### new操作符做了什么
- 创建一个空对象
- 将对象的原型指向构造函数
- 修改构造函数的this指向，将空对象作为构造函数的上下文
- 根据构造函数return返回值是基础类型/引用类型做创建出来的对象值的处理

![](https://gitee.com/luojinan1/markdown-img/raw/master/20220221205405.png)

### CDN
> 内容分发网络
- 全局负载均衡
  - 请求发送到主CDN服务器，智能调度匹配出最佳(近,负载没有超的)节点服务器
- 缓存系统(重点更新缓存,同步源服务器)
  - 命中率(取CDN服务器缓存的数量)
  - 回源率(取源服务器资源的数量)


### 网络和并发
#### http1.0/1.1/2 的区别
- http1.0 每个TCP连接只能发起一次请求，服务器响应后关闭连接。每个请求单独一个TCP连接
- http1.1 TCP连接默认是持久连接，在http1.0中加一个Connetion:keep-alive即可开启,http1.1中手动关闭一个持久连接是 Connetion:close
- 基于TCP持久连接，可以做到一个TCP,多个请求同时发送,管道机制。请求可以同时发送但是响应只能一个一个响应，当一个响应很久时，其他同时发送的请求会一直等待，也就是对头阻塞（请求可以并发，响应不是并发）


5.iframe的优缺点
- 优点
可以解决第三方静态内容加载缓慢的问题；
iframe无刷新文件上传；
iframe跨域通信；
- 缺点
iframe会阻塞主页面的onload事件；
无法被搜索引擎捕获到导致不利于SEO；
增加服务器的http请求；
内存开销大；

8.使用link和@import导入样式的区别
可以通过link和@import引入CSS资源文件，但是具有一下的不同点：

性质不同，link是xhtml标签，无兼容性问题，可用于加载CSS文件的同时还可以进行RSS信息聚合等事务，而@import属于CSS范畴，在CSS2时提出，低版本浏览器不支持，只能用于加载CSS文件；

加载时间不同，link引用CSS随页面载入时同时加载，@import需要在页面加载完毕后被需要时才会加载；

写法不同，link是写在head标签中，而@import在html中只能写在style标签中；

样式权重不同，link引用的样式权重高于@import；

10.浏览器内核引擎
浏览器内核主要分成两部分，渲染引擎和JS引擎，渲染引擎负责页面内容（HTML、XML、图像等）输出到网页中，浏览器的内核不同渲染的效果也不同；JS引擎则是解析和执行javascript进而实现网页的动态效果，且两者越来独立化。

浏览器可以通过cookie、ssessionStorage、localStorage进行对数据进行存储，同源策略下均可以访问，但具有一下不同点：

性质不同，cookies是为了标识用户身份而存储用户本地终端上的数据，自动在同源http请求头中携带，cookies在浏览器和服务器间来回传递信息，而sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存；
存储大小的限制不同，cookie仅可以保存4Kb且数量不超过20条，sessionstorage和localstorage保存的数据可达到5M；
生命周期不同，cookie可以设置生命周期且在过期之前均有效，sessionstorage仅在浏览器窗口关闭或者页面之前有效，若不手动删除localstorage则永久有效；
作用域不同，cookie和localStorage在所有的同源标签页（不同页面但域名端口相同）都是共享，而不同标签页面的sessionStorage不共享


20.HTML页面的渲染过程
浏览器解析HTMLl源码标签，根据标签嵌套创建DOM树，并行加载静态资源文件，每一个HTML标签都是文档树中的一个节点，构成了由documentElement节点为根节点的DOM树；
浏览器解析CSS代码，计算得出样式数据，构建CSSOM树，非法的语法被直接忽略掉，解析CSS的时候按照顺序来定义优先级浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < !important的规则进行解析；
DOM树和CSSOM树组成渲染树并绘制渲染树到屏幕上；
如果渲染树中的节点被移除、位置改变、元素的显示隐藏等属性改变都会重新执行上面的流程，这一个行为称为回流；与重绘不同，重绘是渲染树上的某一个属性需要更新且仅影响外观、风格，不影响布局，例如：修改background-color就属于重绘只是重新绘制到屏幕中上，回流必定造成重绘；

### JS内存

### JSBridge原理

### Event Bus

### 贪心算法

​2.  rem, 计算出375的屏幕，1rem,单位出现小数怎么处理
1.  javascript精度问题的原因
2.  axios用途
3.  性能优化的点，webpack分包，首页资源大小，请求优化，gzip之前还是之后，React重新渲染
4.  国际化站点，cdn, 在页面什么阶段加载国际化文件，如果有20多个语言该怎么做
5.  ssr有没有用过
6.  项目中websocket是解决了什么问题
7.  DOM, BOM, js的关系
8.  React dom绑定事件，与原生事件有什么区别
9.  http2多路复用​

10. http状态 301，302， 304,缓存相关字段
11. cookie、ws是否跨域
12. 触发bfc的方式
13. rem和vw的使用场景
14. 伪代码实现下懒加载

实现一下some, every flatten
函数组件怎么阻止重复渲染

AST作用 or babel实现原理
实现自定义hooks,usePrevious。setcount(count => count + 1)后输出上一次count的值

不同域名共享cookie
on, emit, 实现
防抖的实现
输入url到页面返回结果
缓存的实现方式
React组件重复渲染
webpack分包

webWorker的使用：为什么不在worker里面发出请求，做数据转换呢？


generate函数和async区别
webpack插件实现

父子组件的mounted 调用顺序
$nextTick实现原理
子元素水平垂直居中

算法- “abcdabcda” 求最长的不重复字符串

web安全，pwa，workers，http2
webpack的优化
实现apply，bind