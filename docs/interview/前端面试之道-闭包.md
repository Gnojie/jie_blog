## 闭包

> 函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包

[高阶函数](../js/高阶函数.md#闭包)

闭包 = 高阶函数

闭包的概念聚焦在私有变量缓存和垃圾回收上

高阶函数的概念聚焦在函数可以用在任何地方(函数是一等公民)
通过把一个函数(回调函数)传递给另一个函数，让另一个函数更灵活


### 题: for循环一个var异步函数

```js
for (var i = 1; i <= 5; i++) {
  setTimeout( () => {
    console.log(i) // 6 6 6 6 6 6
  }, i * 1000)
}
```
👆 因为 `setTimeout` 的回调是异步函数，事件循环开始执行时，同步函数i++已经全部执行完了， i 已经全部是6了

🤔 这也是 `eslint` 限制不允许在循环中使用异步的原因，如果异步用到了循环同步逻辑里的变量，将导致不可知的异常

解决办法：
1. 把 `i` 缓存起来，让事件循环执行到的时候可以取到
也就是闭包
```js
for (var i = 1; i <= 5; i++) {
  ;(function(j) {
    setTimeout(() => {
      console.log(j)
    }, j * 1000)
  })(i)
}
```

2. [setTimeout](https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout) 的第三个参数
```js
for (var i = 1; i <= 5; i++) {
  setTimeout((j) => {
      console.log(j)
    },
    i * 1000,
    i
  )
}
```

3. 不用 `var` 用 `let`
```js
for (let i = 1; i <= 5; i++) {
  setTimeout(() => {
    console.log(i)
  }, i * 1000)
}
```

---

🤔: `for` 里面的 `let` 局部变量，为什么在循环传递给异步函数不会++变化 TODO:

---