目的：缓存需要频繁计算的结果,包括异步计算

从目的上看，有点像vue的计算属性具有缓存性质(不能异步)，也像vuex状态仓库缓存结果



实现：
- 利用高阶函数,开辟出一个作用域存放`计算结果`和`执行结束回调事件队列`。实现多个地方调用，作用域相当于全局变量，可以多个地方调用
- `回调函数`的执行，不是简单的执行结束之后调用传入的回调函数，而是先把回调函数存到相应key的事件队列中，异步结束遍历执行回调事件队列。即可做到，异步未结束时，再调一次相同的异步计算，会把第二次的回调函数加入队列，在异步结束时全部执行
- 异步执行结束，遍历执行回调事件队列之后要删除相应key的事件队列

拓展：
- 开辟出来的作用域，只要仍有一个地方调用着，都不会被回收(所有全局变量方案的情况)。因此存在内存泄漏的风险，可以尝试，按时间新旧清除`计算结果`(占内存的主要是结果数据而不是回调函数)


### 跟我现在的全局变量方案有什么不同？

我的设计方案是：
- 利用es6的class类，开辟出作用域存放`计算结果`
- 利用promise，不需要传递回调函数进来执行而是交由调用方编写(更符合人脑思维)
- 但是确实没有考虑异步未结束重复就调用的情况，目前会重复调用，并且计算结果相互覆盖(数据是相同的)

假如让我考虑异步未结束情况，我也不会通过回调队列延后执行相同异步场景
而是让`计算结果`有标识
- 异步开始时就给全局变量`计算结果`中创建key，赋值pending状态的promise，异步未结束就重复请求时，因为key有值，将会返回出promise，在调用方去await来使用


因此值得借鉴的是
- 队列、延后回调的使用
- 处理key的逻辑也由外部决定，多人项目还是不希望key放得太开，反而会有重复缓存

计算属性原理也是这样吗？