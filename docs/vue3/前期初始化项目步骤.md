
环境信息
- vite
- vue3(setup script)
- typescript -标配
- vue-router -vue3生态
- eslint -代码(js、vue)格式化
- stylelint -代码(css)格式化
- tailwind-css -原子css样式库 
- element-plus -vue3组件库


## 脚手架生成初始化项目

vue3官方脚手架生成项目
👇 [vue3官方文档](https://vuejs.org/guide/quick-start.html#creating-a-vue-application)
```bash
npm init vue@latest
```

👇 [create-vue官方指令](https://github.com/vuejs/create-vue)
```bash
npm create vue@latest
```

---

### 🤔 为什么有不同的命令来初始化项目

2个指令可以看出区别是 `init/create`
我们运行
```bash
npm create --help
```
👇 得到
```bash
Usage:
npm init <package-spec> (same as `npx <package-spec>)
npm init <@scope> (same as `npx <@scope>/create`)

Options:
[-y|--yes] [-f|--force] [--scope <@scope>]
[-w|--workspace <workspace-name> [-w|--workspace <workspace-name> ...]]
[-ws|--workspaces] [--no-workspaces-update] [--include-workspace-root]

aliases: create, innit

Run "npm help init" for more info
```
👆 看出 `create` 是 `init` 的别名，并且指引详情文档也是打开 `init`

因此 这里运行 `npm init vue@latest` === `npm create vue@latest`

---

👇 [npm init 官方文档](https://docs.npmjs.com/cli/v8/commands/npm-init)
```bash
npm init foo -> npm exec create-foo
npm init @usr/foo -> npm exec @usr/create-foo
npm init @usr -> npm exec @usr/create
npm init @usr@2.0.0 -> npm exec @usr/create@2.0.0
npm init @usr/foo@2.0.0 -> npm exec @usr/create-foo@2.0.0
```

因此 `npm init vue@latest` 等同于👇
```bash
npx create-vue@latest
```

指令 [create-vue官方指令](https://github.com/vuejs/create-vue)将会得到👇命令行问答

```bash
✔ Project name: … <your-project-name>
✔ Add TypeScript? … No / Yes
✔ Add JSX Support? … No / Yes
✔ Add Vue Router for Single Page Application development? … No / Yes
✔ Add Pinia for state management? … No / Yes
✔ Add Vitest for Unit testing? … No / Yes
✔ Add Cypress for both Unit and End-to-End testing? … No / Yes
✔ Add ESLint for code quality? … No / Yes
✔ Add Prettier for code formatting? … No / Yes

Scaffolding project in ./<your-project-name>...
Done.
```

👇 另外在[vite官方文档](https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project) 创建vue项目指令
```bash
npm create vite <your-project-name> --template vue
```
同理等同于 `npx create-vite` - [create-vite github](https://github.com/vitejs/vite/tree/main/packages/create-vite)

### 脚手架项目已有配置

> 删除冗余代码后的已有配置

```text
.vscode -vscode编辑器局部配置
public -不参与编译的目录资源(图片、css变量等)
src -项目目录和vue2基本一致
.eslint -eslint配置
.gitignore -git忽略配置
env.d.ts -ts配置(https://cn.vitejs.dev/guide/features.html#typescript)
index.html -模板html
package.json
tsconfig.config.json -ts配置
tsconfig.json -ts配置
vite.config.ts -vite配置
```

### vite配置

👇 `vite.config.ts`文件
```ts
import { fileURLToPath, URL } from 'node:url' // 用于配置目录别名

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})
```
👆 只配置了
- 一个`vue3`的`plugin`
  - `@vitejs/plugin-vue`
  - Official plugin that provides Vue SFC support in Vite.
  - 等同于vue2的`loader`(转译`.vue文件`)和`plugin`
- 别名 `alias`
  - [node:url官方文档](https://nodejs.org/api/url.html#urlfileurltopathurl)
  - `fileURLToPath(new URL('./src', import.meta.url))`
  - 等同于以前在webpack里使用的自己封装的`path.resolve`函数
  - `path.resolve(__dirname, 'src')`
  - TODO:区别？

### ts配置
👇 `tsconfig.json`

```json
{
  "extends": "@vue/tsconfig/tsconfig.web.json",
  "include": ["env.d.ts", "src/**/*", "src/**/*.vue"],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },

  "references": [
    {
      "path": "./tsconfig.config.json"
    }
  ]
}
```
TODO: ts配置将单独讲解

### eslint配置
👇 `.eslint.cjs`
```js
/* eslint-env node */
require('@rushstack/eslint-patch/modern-module-resolution')

module.exports = {
  root: true,
  'extends': [
    'plugin:vue/vue3-essential',
    'eslint:recommended',
    '@vue/eslint-config-typescript'
  ],
  parserOptions: {
    ecmaVersion: 'latest'
  }
}
```
👆 使用的是 `CommonJs`的`cjs`文件

配置了3个预设
- `plugin:vue/vue3-essential`
  - `eslint` 会把这种写法解析为对应的依赖包名不需要引入
  - `plugin:vue` -> `eslint-plugin-vue`
  - `essential` 基本的
- `eslint:recommended` 对应依赖包 `eslint`
- `@vue/eslint-config-typescript`
  - 没有采用特殊写法，因此就是对应的依赖包
  - 基于`@typescript-eslint/eslint-plugin`扩展的vue的ts代码格式校验

配合`@vue/eslint-config-typescript` 代码格式化需要安装 `@rushstack/eslint-patch/modern-module-resolution` TODO: 

### 模板html

```html
<head>
  <meta charset="UTF-8">
  <link rel="icon" href="/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>innermanage demo</title>
</head>
```
👇 使用的是esm
```html
<body>
  <div id="app"></div>
  <script type="module" src="/src/main.ts"></script>
</body>
```

### router配置
👇 `router/index.ts`
```ts
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL), // TODO:
  routes: [
    {
      path: '/',
      name: 'home',
      redirect:'home'
    },
    {
      path: '/home',
      name: 'home',
      component: () => import('../views/home.vue')
    }
  ]
})
export default router
```

👇 `main.ts`
```ts
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'

const app = createApp(App)
app.use(router)
app.mount('#app')
```

## vite环境配置
vite 默认设置环境变量`development` `productment`

### 环境变量目录修改

> Vite 在一个特殊的 `import.meta.env` 对象上暴露环境变量

[环境变量和模式-vite官方文档](https://cn.vitejs.dev/guide/env-and-mode.html)

> 环境变量文件目录默认从项目根路径读取
> 通过👇 配置修改
[envdir配置-vite官方文档](https://cn.vitejs.dev/config/shared-options.html#envdir)

新建目录 `build/env` 存放环境变量

👇 `build/env/.env.development`
```bash
# import.meta.env.VITE_SOME_KEY
VITE_SOME_KEY=dev-VITE_SOME_KEY
```
👇 `build/env/.env.production`
```bash
# import.meta.env.VITE_SOME_KEY
VITE_SOME_KEY=prod-VITE_SOME_KEY
```

👇 修改`vite.config.ts`

```ts
export default defineConfig({
  plugins: [ ... ],
  resolve: { ... },
  // 修改环境变量配置目录(默认是根目录)
  envDir: fileURLToPath(new URL('./build/env'))
})
```

### vite打包配置根据环境区分文件
> vite只给环境变量默认设置 dotenv 目录读取配置
> 其他打包配置并没有区分环境
> 因此我们使用函数手动分开使用对应环境的配置文件

👇 `build/index.ts`
```ts
import { devConfig } from './config/dev.config';
import { prodConfig } from './config/prod.config';

// 把配置包装成函数，在运行打包指令时，懒加载函数，不用预编译所有配置文件
export const envResolver = new Map<string,()=>void>([
  ['development', ()=>devConfig], // key为vite打包指令的mode环境变量,默认有development、production(https://cn.vitejs.dev/config/shared-options.html#mode)
  ['production', ()=>prodConfig]
])
```
👆 抛出一个map对象
- key为打包指令的环境变量
- value为一个函数直接抛出对应环境配置文件的内容，实现懒加载

👇 `build/config/*.config.ts`
```ts
// build/config/dev.config.ts
export const devConfig = {}

// build/config/prod.config.ts
export const prodConfig = {}
```
👆 直接抛出一个对象，会由index.ts包装成函数实现懒加载

👇 vite.config.ts
```ts
import { envResolver } from "./build/index";

// 不同打包环境 通用配置
const commonConfig = {
  plugins: [ ... ],
  resolve: { ... },
  envDir: ...
}

// 打包配置函数，改用函数可以获取到打包环境变量mode
// TODO: 怎么定义这个配置函数的参数类型推导
const modeConfigFn = ({ mode }:{mode:string}) => {
  const fn = envResolver.get(mode) || (()=>{})
  return Object.assign(
    commonConfig,
    fn()
  )
}
export default defineConfig(modeConfigFn)
```
👆 引用`import { envResolver } from "./build/index"`会有ts报错，找不到对应模块的类型声明
是因为项目的ts配置了编译目录
👇 在 `tsconfig.config.json` 中添加 `"build/**/*.ts`

`"include": ["vite.config.*", "vitest.config.*", "cypress.config.*", "playwright.config.*", "build/**/*.ts"],`